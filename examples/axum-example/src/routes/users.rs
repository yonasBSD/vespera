use std::collections::{BTreeMap, HashMap};

use serde::{Deserialize, Serialize};
use vespera::{
    Schema,
    axum::{Json, extract::Path},
    schema_type,
};

/// Full user model with all fields
#[derive(Serialize, Deserialize, Clone, Schema)]
pub struct User {
    pub id: u32,
    pub name: String,
    pub email: String,
    /// Internal field - should be omitted in public APIs
    pub internal_score: Option<i32>,
}

// ============================================================================
// schema_type! - Generate request/response types from base model
// ============================================================================
// No more manual struct definitions! Derive them from User.

// Request type: only name and email (auto-generated from User)
schema_type!(CreateUserRequest from User, pick = ["name", "email"]);

// Public response type: User without internal_score (auto-generated)
schema_type!(UserPublicResponse from User, omit = ["internal_score"]);

// Summary type for list views: only id and name (auto-generated)
schema_type!(UserSummary from User, pick = ["id", "name"]);

// DTO type with renamed fields: id -> user_id, name -> display_name
// JSON serialization uses original field names (id, name) for API compatibility
schema_type!(UserDTO from User, pick = ["id", "name"], rename = [("id", "user_id"), ("name", "display_name")]);

// Request type with additional metadata fields
// Picks name/email from User, adds request_id and created_at timestamp
schema_type!(CreateUserWithMeta from User, pick = ["name", "email"], add = [("request_id": String), ("created_at": Option<String>)]);

/// Get all users (returns public response without internal_score)
#[vespera::route(get)]
pub async fn get_users() -> Json<Vec<UserPublicResponse>> {
    // Using UserPublicResponse generated by schema_type!
    Json(vec![
        UserPublicResponse {
            id: 1,
            name: "Alice".to_string(),
            email: "alice@example.com".to_string(),
        },
        UserPublicResponse {
            id: 2,
            name: "Bob".to_string(),
            email: "bob@example.com".to_string(),
        },
    ])
}

/// Get user summaries (minimal fields for list views)
#[vespera::route(get, path = "/summary")]
pub async fn get_users_summary() -> Json<Vec<UserSummary>> {
    // Using UserSummary generated by schema_type!
    Json(vec![
        UserSummary {
            id: 1,
            name: "Alice".to_string(),
        },
        UserSummary {
            id: 2,
            name: "Bob".to_string(),
        },
    ])
}

/// Get user DTO (demonstrates field rename feature)
/// The Rust struct uses user_id/display_name, but JSON uses id/name
#[vespera::route(get, path = "/dto/{id}")]
pub async fn get_user_dto(Path(id): Path<u32>) -> Json<UserDTO> {
    // Using UserDTO generated by schema_type! with renamed fields
    // Rust code uses: user_id, display_name
    // JSON output uses: id, name (via serde rename)
    Json(UserDTO {
        user_id: id,
        display_name: format!("User {}", id),
    })
}

/// Get user by ID (full internal view)
#[vespera::route(get, path = "/{id}")]
pub async fn get_user(Path(id): Path<u32>) -> Json<User> {
    Json(User {
        id,
        name: format!("User {}", id),
        email: format!("user{}@example.com", id),
        internal_score: Some(100),
    })
}

/// Create a new user
/// Request body uses CreateUserRequest (generated from User with only name, email)
#[vespera::route(post)]
pub async fn create_user(Json(user): Json<CreateUserRequest>) -> Json<UserPublicResponse> {
    // Input: CreateUserRequest (auto-generated, picks name + email)
    // Output: UserPublicResponse (auto-generated, omits internal_score)
    Json(UserPublicResponse {
        id: 100,
        name: user.name,
        email: user.email,
    })
}

/// Create a new user with metadata (demonstrates `add` feature)
/// Request body uses CreateUserWithMeta (picks name/email, adds request_id/created_at)
#[vespera::route(post, path = "/with-meta")]
pub async fn create_user_with_meta(
    Json(user): Json<CreateUserWithMeta>,
) -> Json<CreateUserWithMeta> {
    // Input: CreateUserWithMeta (auto-generated with added fields)
    // The struct has: name, email (from User) + request_id, created_at (added)
    Json(CreateUserWithMeta {
        name: user.name,
        email: user.email,
        request_id: user.request_id,
        created_at: Some("2024-01-27T12:00:00Z".to_string()),
    })
}

#[derive(Serialize, Deserialize, Schema)]
pub struct SkipResponse {
    pub name: String,
    #[serde(skip)]
    #[allow(dead_code)]
    pub email: String,

    #[serde(skip, skip_serializing_if = "Option::is_none")]
    #[allow(dead_code)]
    pub email2: Option<String>,

    #[serde(rename = "email3", skip)]
    #[allow(dead_code)]
    pub email3: Option<String>,

    #[serde(rename = "email4", skip_serializing_if = "Option::is_none")]
    pub email4: Option<String>,

    #[serde(rename = "email5", default)]
    pub email5: String,

    #[serde(rename = "email6", default = "default_value")]
    pub email6: String,

    #[serde(rename = "email7", skip)]
    #[allow(dead_code)]
    pub email7: String,

    #[serde(rename = "num", default)]
    pub num: i32,

    pub in_skip: InSkipResponse,
    pub in_skip2: Option<InSkipResponse>,
    pub in_skip3: Vec<InSkipResponse>,
    pub in_skip4: Option<Vec<InSkipResponse>>,
    pub in_skip5: Option<HashMap<String, InSkipResponse>>,
    pub in_skip6: Option<BTreeMap<String, InSkipResponse>>,
}

#[derive(Serialize, Deserialize, Schema)]
pub struct InSkipResponse {
    pub name: String,
}

fn default_value() -> String {
    "default42".to_string()
}

#[vespera::route(get, path = "/skip-response")]
pub async fn skip_response() -> Json<SkipResponse> {
    Json(SkipResponse {
        name: "John Doe".to_string(),
        email: "john.doe@example.com".to_string(),
        email2: Some("john.doe2@example.com".to_string()),
        email3: Some("john.doe3@example.com".to_string()),
        email4: Some("john.doe4@example.com".to_string()),
        email5: "john.doe5@example.com".to_string(),
        email6: "john.doe6@example.com".to_string(),
        email7: "john.doe7@example.com".to_string(),
        num: 0,
        in_skip: InSkipResponse {
            name: "John Doe".to_string(),
        },
        in_skip2: Some(InSkipResponse {
            name: "John Doe".to_string(),
        }),
        in_skip3: vec![InSkipResponse {
            name: "John Doe".to_string(),
        }],
        in_skip4: Some(vec![InSkipResponse {
            name: "John Doe".to_string(),
        }]),
        in_skip5: Some(HashMap::from([(
            "John Doe".to_string(),
            InSkipResponse {
                name: "John Doe".to_string(),
            },
        )])),
        in_skip6: Some(BTreeMap::from([(
            "John Doe".to_string(),
            InSkipResponse {
                name: "John Doe".to_string(),
            },
        )])),
    })
}
